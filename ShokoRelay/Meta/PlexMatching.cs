using Shoko.Plugin.Abstractions.DataModels;
using Shoko.Plugin.Abstractions.Services;
using System.Text;
using ShokoRelay.Helpers;

namespace ShokoRelay.Meta
{
    public class PlexMatching
    {
        private readonly IVideoService _videoService;

        public PlexMatching(IVideoService videoService)
        {
            _videoService = videoService;
        }

        public void ProcessFolder(string path, List<string> results, List<string> errors, bool cleanup = false)
        {
            if (!Directory.Exists(path))
            {
                errors.Add($"Directory not found: {path}");
                return;
            }

            try
            {
                foreach (var subDir in Directory.GetDirectories(path))
                {
                    ProcessFolder(subDir, results, errors, cleanup);
                }
            }
            catch (Exception ex)
            {
                errors.Add($"Error accessing subdirectories in {path}: {ex.Message}");
            }

            var seriesIds = new HashSet<int>();
            ISeries? representativeSeries = null;

            var files = Directory.GetFiles(path);
            if (!files.Any() && !cleanup) return;

            foreach (var file in files)
            {
                var videoFile = _videoService.GetVideoFileByAbsolutePath(file);
                var series = videoFile?.Video?.Series?.FirstOrDefault();
                
                if (series != null)
                {
                    seriesIds.Add(series.ID);
                    representativeSeries = series;
                }
            }

            string plexmatchPath = Path.Combine(path, ".plexmatch");

            if (seriesIds.Count > 1)
            {
                errors.Add($"Multi-Series Error in {path}: Detected Series IDs {string.Join(", ", seriesIds)}");
                if (cleanup && File.Exists(plexmatchPath))
                {
                    File.Delete(plexmatchPath);
                    results.Add($"Cleaned up misplaced .plexmatch in: {path} (Multi-series conflict)");
                }
            }
            else if (representativeSeries != null)
            {
                WriteToDirectory(representativeSeries, path);
                results.Add($"Generated/Updated .plexmatch for: {representativeSeries.PreferredTitle} in {path}");
            }
            else if (cleanup && File.Exists(plexmatchPath))
            {
                File.Delete(plexmatchPath);
                results.Add($"Cleaned up orphaned .plexmatch in: {path}");
            }
        }

        private void WriteToDirectory(ISeries series, string targetPath)
        {
            var seriesVideos = series.Episodes
                .SelectMany(e => e.VideoList)
                .GroupBy(v => v.ID)
                .Select(g => g.First())
                .ToList();

            if (!seriesVideos.Any()) return;

            string content = BuildContent(series, seriesVideos);
            string filePath = Path.Combine(targetPath, ".plexmatch");

            File.WriteAllText(filePath, content, Encoding.UTF8);
        }

        private string BuildContent(ISeries series, IEnumerable<IVideo> videos)
        {
            var sb = new StringBuilder();
            sb.AppendLine("# Generated by Shoko Relay");
            sb.AppendLine($"Guid: {ShokoRelayInfo.AgentScheme}://show/{series.ID}");
            sb.AppendLine();

            var mappings = MapHelper.GetSeriesFileData(series).Mappings;

            if (!mappings.Any()) return sb.ToString();

            // Compute padding from max episode number
            int maxEp = mappings.Max(m => m.Coords.EndEpisode ?? m.Coords.Episode);
            int padding = Math.Max(2, maxEp.ToString().Length);
            string epFormat = $"D{padding}";

            // Compute max episode string length for alignment
            int maxEpStrLen = 0;
            foreach (var m in mappings)
            {
                string epPart = $"S{m.Coords.Season:D2}E{m.Coords.Episode.ToString(epFormat)}";
                if (m.Coords.EndEpisode.HasValue && m.Coords.EndEpisode.Value != m.Coords.Episode)
                {
                    epPart += $"-{m.Coords.EndEpisode.Value.ToString(epFormat)}";
                }
                maxEpStrLen = Math.Max(maxEpStrLen, epPart.Length);
            }

            // Sort by filename and output
            var ordered = mappings.OrderBy(m => m.FileName).ToList();

            foreach (var m in ordered)
            {
                string epPart = $"S{m.Coords.Season:D2}E{m.Coords.Episode.ToString(epFormat)}";
                if (m.Coords.EndEpisode.HasValue && m.Coords.EndEpisode.Value != m.Coords.Episode)
                {
                    epPart += $"-{m.Coords.EndEpisode.Value.ToString(epFormat)}";
                }

                // Pad filename after colon to align vertically
                string paddedFileName = m.FileName.PadLeft(m.FileName.Length + (maxEpStrLen - epPart.Length));

                sb.AppendLine($"ep: {epPart}: {paddedFileName}");
            }

            return sb.ToString();
        }
    }
}